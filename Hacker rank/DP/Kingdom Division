https://www.hackerrank.com/challenges/kingdom-division/problem

// wrong answer. 
// Test case 1 5 & 7 - 5 means 5 has two parents. Thus, postorderTraverse cannot solve this problem because it is not a tree. 
// We should use depth first search approach.
#include <vector>
#include <iostream>
using namespace std;

struct Node
{
    long name;
    double numWays;
    long numSon;
    Node* left;
    Node* right;
    Node* parent;

    Node(int name2)
    {
        name = name2;
        numWays = 0;
        numSon = 0;
        left = nullptr;
        right = nullptr;
        parent = nullptr;
    }
};

void CalculateNumWays(Node* node)
{
    if (node->left != nullptr)
        node->numSon += node->left->numSon + 1;
    if (node->right != nullptr)
        node->numSon += node->right->numSon + 1;

    if (node->numSon >= 3 )
    {
        if (node->parent != nullptr)
        {
            if (node->left == nullptr || node->right == nullptr)
            {
                node->numWays = node->right == nullptr ? node->left->numWays + node->left->left->numWays : node->right->numWays + node->right->numWays;
            }
            else
            {
                    node->numWays = node->left->numWays * node->right->numWays * 2;
            }
        }
        else
        {
            if (node->left == nullptr || node->right == nullptr)
            {
                node->numWays = node->right == nullptr ? node->left->numWays : node->right->numWays;
            }
            else
            {
                node->numWays = node->left->numWays * node->right->numWays;
            }
        }
    }
    else
    {
        node->numWays = 2;
    }
}

void PostorderTraverse(Node* node)
{
    if (node == nullptr)
        return;

    PostorderTraverse(node->left);
    PostorderTraverse(node->right);
    CalculateNumWays(node);
    //cout << "Node " << node->name << " : " << node->numWays << endl;
}

Node* FindRoot(Node* node)
{
    while (node->parent != nullptr)
        node = node->parent;

    return node;
}

int main()
{
    long n(0);
    cin >> n;
    // make a tree
    std::vector<Node*> tree(n + 1);
    int name(0);
    for (auto& i : tree)
        i = new Node(name++);

    for (int i = 1; i < n; ++i)
    {
        int u(0), v(0);
        cin >> u >> v;
        if (tree[u]->left == nullptr)
            tree[u]->left = tree[v];
        else
            tree[u]->right = tree[v];
        tree[v]->parent = tree[u];
    }
    Node* root = FindRoot(tree[1]);
    PostorderTraverse(root);
    cout << root->numWays << endl;

}
